# 697. 数组的度

给定一个非空且只包含非负数的整数数组 nums，数组的度的定义是指数组里任一元素出现频数的最大值。

你的任务是在 nums 中找到与 nums 拥有相同大小的度的最短连续子数组，返回其长度。
```shell
示例 1：
输入：[1, 2, 2, 3, 1]
输出：2
解释：
输入数组的度是2，因为元素1和2的出现频数最大，均为2.
连续子数组里面拥有相同度的有如下所示:
[1, 2, 2, 3, 1], [1, 2, 2, 3], [2, 2, 3, 1], [1, 2, 2], [2, 2, 3], [2, 2]
最短连续子数组[2, 2]的长度为2，所以返回2.

示例 2：
输入：[1,2,2,3,1,4,2]
输出：6

提示：
nums.length 在1到 50,000 区间范围内。
nums[i] 是一个在 0 到 49,999 范围内的整数。
```

### python字典
```python
# 执行用时：80 ms, 在所有 Python3 提交中击败了59.80% 的用户
# 内存消耗：15.8 MB, 在所有 Python3 提交中击败了29.07% 的用户

# 遍历一遍数组，字典存储相同元素的个数和起始结束坐标
# 再遍历字典，得出结果

class Solution:
    def findShortestSubArray(self, nums: List[int]) -> int:
        dic = {}

        for i in range(len(nums)):
            if nums[i] not in dic:
                dic[nums[i]] = [1, i, i]
            else:
                dic[nums[i]][0] += 1
                dic[nums[i]][2] = i

        count = 0
        min_len = len(nums)

        for key, val in dic.items():
            if val[0] > count:
                count = val[0]
                min_len = val[2] - val[1]
            elif val[0] == count:
                min_len = min(min_len, val[2] - val[1])

        return min_len + 1
```

### c++版本
```c++
// 执行用时：48 ms, 在所有 C++ 提交中击败了87.62% 的用户
// 内存消耗：24.9 MB, 在所有 C++ 提交中击败了63.11% 的用户

class Solution {
public:
    int findShortestSubArray(vector<int>& nums) {
        unordered_map<int, vector<int>> num_map;

        for(int i = 0; i < nums.size(); ++i){
            if(num_map.count(nums[i]) == 0){
                num_map[nums[i]] = {1, i, i};
            }else{
                ++num_map[nums[i]][0];
                num_map[nums[i]][2] = i;
            }
        }

        int count = 0;
        int min_len = nums.size();

        for(auto it = num_map.begin(); it != num_map.end(); ++it){
            if((it->second)[0] > count){
                count = (it->second)[0];
                min_len = (it->second)[2] - (it->second)[1];
            }else if((it->second)[0] == count){
                min_len = min(min_len, (it->second)[2] - (it->second)[1]);
            }
        }
        return min_len + 1;
    }
};
```